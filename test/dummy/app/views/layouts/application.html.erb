<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1">
    <title>GhosttyRails Test</title>
    <style>
      *, *::before, *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: system-ui, sans-serif;
        background: #f5f5f5;
      }
      .bg-background { background: #f5f5f5; }
      .max-w-5xl { max-width: 64rem; }
      .mx-auto { margin-left: auto; margin-right: auto; }
      .p-4 { padding: 1rem; }
      .p-1 { padding: 0.25rem; }
      .mb-4 { margin-bottom: 1rem; }
      .mb-2 { margin-bottom: 0.5rem; }
      .flex { display: flex; }
      .flex-col { flex-direction: column; }
      .flex-1 { flex: 1 1 0%; }
      .items-center { align-items: center; }
      .justify-between { justify-content: space-between; }
      .gap-2 { gap: 0.5rem; }
      .text-xl { font-size: 1.25rem; }
      .font-bold { font-weight: 700; }
      .text-sm { font-size: 0.875rem; }
      .text-danger { color: #dc2626; }
      .text-text-muted { color: #6b7280; }
      .rounded { border-radius: 0.25rem; }
      .hidden { display: none !important; }
      .fixed { position: fixed; }
      .inset-0 { top:0; right:0; bottom:0; left:0; }
      .z-50 { z-index: 50; }
      .overflow-hidden { overflow: hidden; }
      .min-h-0 { min-height: 0; }
      .hover\:bg-gray-200:hover { background: #e5e7eb; }
    </style>
    <script type="module">
      import { Application, Controller } from "https://unpkg.com/@hotwired/stimulus@3.2.2/dist/stimulus.js"
      import { createConsumer } from "https://unpkg.com/@rails/actioncable@8.0.200/src/index.js"

      // Minimal terminal stub for tests that don't
      // load the real Ghostty WASM. Tests that need
      // the real terminal should skip this stub.
      const Stimulus = Application.start()

      Stimulus.register("terminal", class extends Controller {
        static targets = [
          "authMethod", "connectBtn",
          "connectionForm", "container",
          "content", "disconnectBtn", "host",
          "page", "password", "passwordGroup",
          "port", "status", "subtitleActions",
          "user"
        ]

        static values = {
          autoConnect: { type: Boolean, default: false },
          channelName: { type: String, default: "TerminalChannel" },
          hostId: { type: String, default: "" },
          mode: { type: String, default: "local" },
          savedTheme: { type: String, default: "Tokyo Night" },
          sshAuthMethod: { type: String, default: "key" },
          sshHost: { type: String, default: "" },
          sshPort: { type: String, default: "22" },
          sshUser: { type: String, default: "root" }
        }

        connect () {
          // For system tests: render a colored
          // terminal-like surface immediately,
          // simulating what Ghostty WASM would do.
          if (this.autoConnectValue) {
            this.renderStubTerminal()
          }
        }

        refitTerminal () {
          // Resize the stub surface to fill its
          // container after fullscreen toggle
          const stub = this.containerTarget
            .querySelector("[data-stub-terminal]")
          if (stub) {
            stub.style.width = "100%"
            stub.style.height = "100%"
          }
        }

        renderStubTerminal () {
          // Tokyo Night palette used for the demo
          const c = {
            bg: "#1a1b26", fg: "#a9b1d6",
            red: "#f7768e", green: "#9ece6a",
            yellow: "#e0af68", blue: "#7aa2f7",
            magenta: "#bb9af7", cyan: "#7dcfff",
            white: "#c0caf5", dim: "#414868",
            black: "#15161e",
            bRed: "#f7768e", bGreen: "#9ece6a",
            bYellow: "#e0af68", bBlue: "#7aa2f7",
            bMagenta: "#bb9af7", bCyan: "#7dcfff",
            bWhite: "#c0caf5", bBlack: "#414868"
          }
          const s = (color, text) =>
            `<span style="color:${color}">${text}</span>`
          const b = (color, text) =>
            `<span style="color:${color};` +
            `font-weight:bold">${text}</span>`

          // Ghost ASCII art, colored column by column
          // in a spectral gradient
          const ghostLines = [
            "     .-========-.     ",
            "    //  @@  @@  \\\\    ",
            "   ||            ||   ",
            "   ||            ||   ",
            "   ||    \\__/    ||   ",
            "    \\\\          //    ",
            "     \\\\ /\\\\ /\\\\ //     ",
            "      \\/  \\/  \\/      "
          ]
          const ghostColors = [
            c.blue, c.blue, c.cyan, c.cyan,
            c.green, c.green, c.cyan, c.cyan,
            c.green, c.green, c.yellow,
            c.yellow, c.yellow, c.yellow,
            c.green, c.green, c.cyan, c.cyan,
            c.green, c.green, c.blue, c.blue
          ]
          const ghostArt = ghostLines.map(line => {
            let out = ""
            for (let i = 0; i < line.length; i++) {
              const ch = line[i]
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
              const col = ghostColors[i] || c.fg
              if (ch === "@") {
                out += s(c.white, ch)
              } else if (ch === " ") {
                out += ch
              } else {
                out += s(col, ch)
              }
            }
            return out
          })

          // System info lines beside the ghost
          const info = [
            b(c.blue, "ghostty") +
              s(c.dim, "@") +
              b(c.green, "rails"),
            s(c.dim,
              "----------------------"),
            b(c.red, "Engine  ") +
              s(c.fg,
                "GhosttyRails v0.1.0"),
            b(c.yellow, "Terminal") +
              s(c.fg,
                " Ghostty WASM"),
            b(c.green, "Channel ") +
              s(c.fg,
                " ActionCable + PTY"),
            b(c.cyan, "Modes   ") +
              s(c.fg,
                " Local | SSH"),
            b(c.blue, "Themes  ") +
              s(c.fg, " 10 built-in"),
            b(c.magenta, "Ruby    ") +
              s(c.fg, " >= 3.2") +
              s(c.dim, " | ") +
              b(c.magenta, "Rails") +
              s(c.fg, " >= 7.1")
          ]

          // Compose ghost art + info side by side
          const pad = "   "
          const rows = Math.max(
            ghostArt.length, info.length
          )
          let output = ""
          for (let i = 0; i < rows; i++) {
            const left = (i < ghostArt.length)
              ? ghostArt[i] : " ".repeat(22)
            const right = (i < info.length)
              ? info[i] : ""
            output += left + pad + right + "\n"
          }

          // Blank line then color swatches:
          // normal colors, then bright colors
          output += "\n"
          const normal = [
            c.black, c.red, c.green, c.yellow,
            c.blue, c.magenta, c.cyan, c.white
          ]
          const bright = [
            c.bBlack, c.bRed, c.bGreen,
            c.bYellow, c.bBlue, c.bMagenta,
            c.bCyan, c.bWhite
          ]
          // Three-line color blocks using
          // background-colored spans
          const block = "\u2588\u2588\u2588"
          for (const palette of [normal, bright]) {
            output += "  "
            for (const color of palette) {
              output +=
                `<span style="color:${color}">` +
                `${block}</span> `
            }
            output += "\n"
          }

          // Prompt
          output += "\n"
          output += s(c.green, "ghostty-rails") +
            s(c.dim, " $ ") +
            s(c.fg, "_")

          const el = document.createElement("div")
          el.setAttribute("data-stub-terminal", "true")
          el.style.cssText =
            "width:100%;height:100%;" +
            "background:#1a1b26;" +
            "color:#a9b1d6;" +
            "font-family:monospace;" +
            "font-size:13px;" +
            "line-height:1.4;" +
            "padding:12px 16px;" +
            "overflow:hidden;" +
            "white-space:pre;"
          el.innerHTML = output
          this.containerTarget.appendChild(el)

          // Update page background like the
          // real controller does
          const page = this.element.querySelector(
            "[data-terminal-target='page']"
          )
          if (page) {
            page.style.backgroundColor = "#1a1b26"
          }
          const content = this.element.querySelector(
            "[data-terminal-target='content']"
          )
          if (content) {
            content.style.backgroundColor = "#1a1b26"
          }
        }
      })

      Stimulus.register("terminal-fullscreen", class extends Controller {
        static targets = [
          "wrapper", "btn",
          "maximizeIcon", "minimizeIcon",
          "meta", "terminalWrap"
        ]

        FULLSCREEN_CLASSES = [
          "fixed", "inset-0", "z-50",
          "bg-background", "p-4", "flex",
          "flex-col", "overflow-hidden"
        ]

        isFullscreen = false
        savedClasses = []
        savedStyles = {}
        savedMetaClasses = []
        savedTerminalStyles = {}
        savedTerminalClasses = []
        savedBodyOverflow = ""

        connect () {
          this.setButtonLabel("maximize")
        }

        toggle () {
          if (this.isFullscreen) {
            this.exitFullscreen()
          } else {
            this.enterFullscreen()
          }
        }

        handleKeydown (event) {
          if (event.key === "Escape" && this.isFullscreen) {
            event.preventDefault()
            this.exitFullscreen()
          }
        }

        enterFullscreen () {
          const el = this.wrapperTarget
          this.savedStyles = {
            height: el.style.height,
            maxWidth: el.style.maxWidth,
            overflow: el.style.overflow
          }
          this.savedClasses = Array.from(el.classList)
          this.savedBodyOverflow = document.body.style.overflow
          document.body.style.overflow = "hidden"
          el.className = ""
          el.classList.add(...this.FULLSCREEN_CLASSES)
          el.style.height = "100vh"
          el.style.maxWidth = ""

          if (this.hasMetaTarget) {
            this.savedMetaClasses = Array.from(this.metaTarget.classList)
            this.metaTarget.classList.remove("mb-4")
            this.metaTarget.classList.add("mb-2")
          }

          if (this.hasTerminalWrapTarget) {
            const tw = this.terminalWrapTarget
            this.savedTerminalStyles = {
              height: tw.style.height,
              width: tw.style.width
            }
            this.savedTerminalClasses = Array.from(tw.classList)
            tw.style.height = ""
            tw.style.width = ""
            tw.classList.add("flex-1", "min-h-0")
          }

          this.setButtonLabel("minimize")
          this.isFullscreen = true
          this.dispatch("changed", { detail: { fullscreen: true } })
        }

        exitFullscreen () {
          const el = this.wrapperTarget
          document.body.style.overflow = this.savedBodyOverflow
          el.className = ""
          this.savedClasses.forEach(c => el.classList.add(c))
          el.style.height = this.savedStyles.height || ""
          el.style.maxWidth = this.savedStyles.maxWidth || ""
          el.style.overflow = this.savedStyles.overflow || ""

          if (this.hasMetaTarget) {
            this.metaTarget.className = ""
            this.savedMetaClasses.forEach(c => this.metaTarget.classList.add(c))
          }

          if (this.hasTerminalWrapTarget) {
            const tw = this.terminalWrapTarget
            tw.className = ""
            this.savedTerminalClasses.forEach(c => tw.classList.add(c))
            tw.style.height = this.savedTerminalStyles.height || ""
            tw.style.width = this.savedTerminalStyles.width || ""
          }

          this.setButtonLabel("maximize")
          this.isFullscreen = false
          window.scrollTo(0, 0)
          this.dispatch("changed", { detail: { fullscreen: false } })
        }

        setButtonLabel (name) {
          this.btnTarget.setAttribute(
            "data-fullscreen-state", name
          )
          this.btnTarget.setAttribute(
            "aria-label",
            name === "minimize"
              ? "Exit fullscreen"
              : "Enter fullscreen"
          )
          if (this.hasMaximizeIconTarget) {
            this.maximizeIconTarget.hidden =
              name === "minimize"
          }
          if (this.hasMinimizeIconTarget) {
            this.minimizeIconTarget.hidden =
              name === "maximize"
          }
        }
      })
    </script>
  </head>
  <body>
    <%= yield %>
  </body>
</html>
